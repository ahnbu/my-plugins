# 개발 영역 문서 관리 — 웹 리서치 결과

> 날짜: 2026-02-25
> 목적: ADR, Docs-as-Code, API 문서화, Engineering Wiki, AI 보조 개발 문서화에 대한 현황 조사
> 대상 환경: 1인 개발자, Claude Code 플러그인 개발, Git 기반

---

## 2-1. Architecture Decision Record (ADR)

### Michael Nygard의 원본 ADR 형식

Michael Nygard가 2011년 제안한 원본 형식은 5개 섹션으로 구성된다:

| 섹션 | 내용 |
|------|------|
| **Title** | 짧은 명사구 (예: "ADR 1: Use PostgreSQL") |
| **Status** | Proposed / Accepted / Deprecated / Superseded |
| **Context** | 결정이 필요한 상황과 제약 조건 |
| **Decision** | 선택한 방안과 이유 |
| **Consequences** | 결정의 긍정적/부정적 결과 |

핵심 철학: **"한 결정 = 한 문서"**, 짧고 변경 불가(immutable)하게 유지. 결정이 바뀌면 새 ADR로 supersede.

### ADR의 진화

**Y-Statements** (Olaf Zimmermann):
- 한 문장 형식: *"In the context of {use case}, facing {concern}, we decided for {option} to achieve {quality}, accepting {downside}."*
- 장점: 핵심을 한 문장으로 압축
- 단점: 문장이 길어지면 가독성 저하. 초보자에게 어려움

**MADR (Markdown ADR)**:
- Y-Statement의 모든 요소를 섹션 기반 Markdown으로 풀어낸 형식
- **MADR 4.0.0** (2024-09-17 릴리스): "bare"와 "minimal" 템플릿 제공
- 추가 섹션: Decision Drivers, Considered Options, Pros/Cons of each option
- GitHub: [adr/madr](https://github.com/adr/madr)

**Decision Records** (일반화):
- 아키텍처에 국한하지 않고, 모든 중요 결정을 기록하는 방향으로 확장
- AWS, Microsoft 등이 공식 가이드라인에 채택

### 실무 적용 사례와 성공/실패 패턴

**성공 패턴**:
- `/docs/adr/` 폴더에 코드와 함께 버전 관리 — PR 리뷰에 ADR 포함
- "돌이키기 어려운 결정"에만 작성 — 모든 결정에 ADR을 쓰면 피로도 급증
- AWS 권장: ADR 미팅은 30-45분, 1-3회 readout이면 충분

**실패 패턴**:
- 별도 Wiki에 ADR 저장 → 코드와 분리되어 방치
- 너무 상세하게 작성 → solution design과 혼동, 유지보수 부담
- 승인 프로세스 과중 → 작성 회피
- 5가지 위험 (문서화하지 않은 결정): 커뮤니케이션 단절, 지식 유실, 컨텍스트 상실, 실수 반복, 감사 불가

**출처**:
- [AWS Architecture Blog - Master ADRs](https://aws.amazon.com/blogs/architecture/master-architecture-decision-records-adrs-best-practices-for-effective-decision-making/)
- [Microsoft Azure - ADR](https://learn.microsoft.com/en-us/azure/well-architected/architect-role/architecture-decision-record)
- [ADR GitHub](https://adr.github.io/)
- [Adam Cogan - Essential Role of ADRs](https://adamcogan.com/2024/10/09/essential-role-of-architectural-decision-records/)

### ADR 도구

| 도구 | 특징 | 적합 대상 |
|------|------|-----------|
| **[Log4brains](https://github.com/thomvaill/log4brains)** | CLI + 정적 사이트 생성, MADR 기본 템플릿, `npm install -g log4brains` | 팀 프로젝트, ADR을 웹으로 공유 |
| **[adr-tools](https://github.com/npryce/adr-tools)** | bash CLI, Nygard 형식 기본, 경량 | 리눅스/맥 환경, 최소주의 |
| **[adr-tools-python](https://pypi.org/project/adr-tools-python/)** | Python 포팅, 크로스 플랫폼 | Python 환경 |
| **[adr-log](https://github.com/adr/adr-log)** | ADR 목차(TOC) 자동 생성 | 보조 도구 |
| **단순 Markdown 파일** | 도구 없이 `docs/adr/` 폴더에 수동 관리 | 1인 개발자, 소규모 |

### 우리 환경에 대한 시사점

- **1인 개발자에게 Log4brains는 과함**. `docs/decisions/` 폴더에 Markdown 파일로 충분
- 플러그인별 설계 결정(예: "왜 hooks.json에 이중 배열인가", "왜 ensure-commands.js를 SessionStart에 연결했나")을 기록하면 3개월 후 자신에게 큰 도움
- MADR minimal 템플릿이 가장 적합: Context, Decision, Consequences 3섹션
- **CHANGELOG.md와 ADR은 보완적**: CHANGELOG = "무엇이 바뀌었나", ADR = "왜 그렇게 결정했나"

---

## 2-2. Docs-as-Code 파이프라인

### 개념과 핵심 원칙

Docs-as-Code는 문서를 코드와 동일한 도구·워크플로우로 관리하는 방식:
- **텍스트 기반** 포맷 (Markdown, reStructuredText, AsciiDoc)
- **Git** 버전 관리
- **PR 리뷰** — 코드 리뷰와 동일한 품질 게이트
- **CI/CD** — 빌드·배포 자동화
- **정적 사이트 생성기** (SSG)로 배포

### 실무 구현 파이프라인

```
Markdown 작성 → Git commit/PR → CI 검증(lint, link check, spell check) → SSG 빌드 → 배포
```

### 도구 체인 비교

| 도구 | 언어/생태계 | 핵심 강점 | 약점 | 적합 대상 |
|------|-------------|-----------|------|-----------|
| **[Docusaurus](https://docusaurus.io/)** | React/JS | 버전닝, i18n, MDX(React 컴포넌트), Meta 지원 | JS 생태계 의존 | 프론트엔드/JS 프로젝트 |
| **[MkDocs](https://www.mkdocs.org/)** + Material | Python | 단순, 빠름, 라이브 프리뷰, [Material 테마](https://squidfunk.github.io/mkdocs-material/) | 커스터마이징 한계 | Python 프로젝트, 빠른 셋업 |
| **[Sphinx](https://www.sphinx-doc.org/)** | Python | docstring 자동 문서화, PDF/ePub 출력, 강력한 크로스 레퍼런스 | 학습 곡선, rST 기본 | 라이브러리/API 레퍼런스 |
| **[GitBook](https://www.gitbook.com/)** | SaaS + Git | Git 동기화 + 웹 에디터, 브랜치 워크플로우 | 무료 플랜 제한 | 오픈소스, 팀 문서 |

### 성공 사례

**Pinterest — PDocs**:
- Markdown + Git 기반 내부 문서 플랫폼 자체 개발
- 2022년 출시 후 **140+ 문서 프로젝트, 60+ GitHub 리포, 80+ 팀** 채택
- Wiki→PDocs 변환기 제공 → 2개월 만에 문서 프로젝트 20% 증가
- AI 챗봇 통합: 문서 내에서 AI 질문 가능, Slack 봇이 관련 문서 자동 공유
- 출처: [Pinterest Engineering Blog](https://medium.com/pinterest-engineering/adopting-docs-as-code-at-pinterest-4f18ad169c25)

**Squarespace — Backstage + TechDocs**:
- Markdown + Git + Backstage(개발자 포털) 조합
- Mermaid로 다이어그램 버전 관리
- PR 리뷰로 코드와 문서 동시 승인 → "누구나 리포 접근만 있으면 문서 변경 제안 가능"
- 출처: [Squarespace Engineering Blog](https://engineering.squarespace.com/blog/2025/making-documentation-simpler-and-practical-our-docs-as-code-journey)

**실패 사례 공통 패턴**:
- 도구만 도입하고 문화 전환 없음 → 결국 방치
- 문서를 코드와 별도 리포에 분리 → sync 깨짐
- 자동 검증(lint, link check) 없음 → 품질 하락

### 우리 환경에 대한 시사점

- **이미 Docs-as-Code를 실천 중**: CLAUDE.md, CHANGELOG.md, handoff/ 문서가 Git 리포에 동거
- 부족한 것: **자동 검증**(broken link check, 포맷 lint)과 **검색 가능한 뷰**
- MkDocs Material은 설정 5분이면 끝남 — 플러그인 문서를 웹으로 볼 필요가 생기면 최소 비용 옵션
- 현재 규모에서는 SSG 없이 GitHub 마크다운 렌더링으로 충분

---

## 2-3. API 문서화와 SSOT

### SSOT 원칙의 문서 적용

**Single Source of Truth (SSOT)**: 모든 데이터/정보가 하나의 권위 있는 출처에서 관리되는 원칙.

문서에 적용하면:
- **하나의 원본**에서 다른 모든 형식(HTML, PDF, SDK)이 파생
- 수동 동기화 제거 → 불일치 방지
- OpenAPI spec이 API 문서의 SSOT 역할

### Code-First vs Design-First

| 비교 항목 | Code-First | Design-First |
|-----------|------------|--------------|
| **워크플로우** | 코드 작성 → 코드에서 spec 생성 | spec 작성 → spec에서 코드/mock 생성 |
| **문서 시점** | 사후(afterthought) | 사전(contract) |
| **장점** | 빠른 프로토타이핑, 기존 코드 노출 | 병렬 작업 가능, 일관성, mock 서버 |
| **단점** | 문서 누락 위험, 워터폴 경향 | 설계 단계 시간 투자 |
| **적합** | 소규모, 내부 API, 빠른 반복 | 대규모 팀, 외부 API, 계약 기반 |

**1인 개발자에게는** Code-First가 현실적. 단, 주석/데코레이터에서 OpenAPI를 자동 생성하는 도구 활용 권장.

### 최신 API 문서 도구 (2025)

| 도구 | 핵심 특징 | 가격 | 적합 대상 |
|------|-----------|------|-----------|
| **[Scalar](https://scalar.com/)** | 오픈소스, 깔끔한 UI, 내장 API 클라이언트, 다크모드 기본 | 무료(1인) / $12/seat | 1인 개발자, 오픈소스 |
| **[Redocly](https://redocly.com/)** | Stripe 스타일 2-3패널, 자체 호스팅 가능, API governance | 무료(셀프) / $10/mo Pro | 단일 API, 브랜딩 중시 |
| **[Stoplight](https://stoplight.io/)** | 비주얼 API 디자인 에디터, mock 서버, 스타일 가이드 | 유저당 과금 | 팀 협업, Design-First |
| **[Bump.sh](https://bump.sh/)** | 자동 변경 로그, 브레이킹 체인지 감지, SEO 최적화 | 클라우드 only | CI/CD 중심, 버전 관리 |
| **[ReadMe](https://readme.com/)** | 개발자 포털, 피드백 포럼, AI 챗봇, 분석 | $99/mo~ | DevRel, SaaS |

**출처**:
- [APIs You Won't Hate - Top 5 API Docs Tools 2025](https://apisyouwonthate.com/blog/top-5-best-api-docs-tools/)
- [Swagger - Code-First vs Design-First](https://swagger.io/blog/code-first-vs-design-first-api/)
- [Theneo - API Documentation Best Practices 2025](https://www.theneo.io/blog/api-documentation-best-practices-guide-2025)

### 우리 환경에 대한 시사점

- 현재 플러그인에 REST API는 없음. 그러나 **plugin.json과 hooks.json이 사실상의 인터페이스 스펙**
- SSOT 원칙 적용: `plugin.json`이 메타정보의 단일 원본, `marketplace.json`이 이를 참조 — 이미 실천 중
- pre-commit hook으로 version 일치를 검증하는 것은 SSOT 원칙의 좋은 구현

---

## 2-4. Engineering Wiki와 Runbook

### Engineering Wiki의 성공/실패 패턴

**"문서 무덤"이 되는 이유** ([DEV Community](https://dev.to/kislay/why-your-engineering-wiki-is-a-graveyard-and-how-to-fix-it-2eme)):

1. **목적지 문제 (Destination Problem)**: Wiki가 개발 도구 밖에 존재 → 컨텍스트 스위칭 비용 → 업데이트 회피
2. **컨텍스트 갭**: "무엇"은 저장되지만 "왜"는 사라짐 — Slack 대화, Zoom 녹화에 묻힘
3. **신뢰 침식**: 한 번 오래된 문서를 만나면 전체 위키에 대한 신뢰 소실 → 시니어가 "인간 라우터" 역할
4. **유지보수 마찰**: Stack Overflow 설문에서 **78%의 개발자**가 "오래된 정보"를 내부 문서 불신의 1순위 이유로 지목
5. **검색성 문제**: **65%의 개발자**가 정보를 찾는 데 읽는 시간보다 더 많은 시간 소비

**해결책**:
- 문서를 개발 워크플로우에 임베드 (GitHub, IDE, Slack)
- AI 기반 문서 신선도 감지: 연결된 코드가 리팩터링되면 문서 자동 플래그
- Knowledge Graph: PR, 이슈, 토론, 미팅 간 관계 매핑

### Wiki 플랫폼 비교

| 플랫폼 | 강점 | 약점 | 적합 대상 |
|--------|------|------|-----------|
| **Notion** | 유연성, 올인원, 빠른 에디터, 커스텀 DB | 구조 없으면 혼란, 기술 문서 특화 아님 | 스타트업, 다목적 |
| **Confluence** | Jira 통합, 권한 관리, 무료 10명 | UI 구식, 기술 문서에 부적합 | Atlassian 생태계 팀 |
| **GitBook** | Git 동기화, 브랜치 워크플로우, Markdown | 무료 제한 | 개발자 문서, 오픈소스 |

### Runbook Best Practices

**구조 원칙** ([IncidentHub](https://blog.incidenthub.cloud/The-No-Nonsense-Guide-to-Runbook-Best-Practices)):
- 하나의 런북 = 하나의 목적 (decision tree 형식)
- 서비스명을 제목에 포함 → 검색 최적화
- 간결하게 — 인시던트 상황은 고압적, 불필요한 설명 제거
- 대시보드/자동화 링크 포함

**유지보수**:
- 포스트모템 후 자동으로 런북 업데이트 트리거
- 새 온보딩 멤버에게 런북 검증 역할 부여 (hidden assumption 발견)
- 정기 모의 인시던트로 런북 테스트

**자동화 트렌드 (2025)**:
- 알림 → 런북 자동 링크 (Prometheus alert description에 URL 삽입)
- 런북 자동화: 수동 절차를 워크플로우로 전환, pre-check → action → health confirm
- MTTR 감소: 대응 첫 5분을 "논의"에서 "실행"으로 전환

**소유권**: "You build it, you run it" — 서비스 팀이 런북 소유, 인프라/공통은 SRE 소유.

**출처**:
- [IncidentHub - Runbook Best Practices](https://blog.incidenthub.cloud/The-No-Nonsense-Guide-to-Runbook-Best-Practices)
- [Engini - Runbook Automation 2025](https://engini.io/blog/runbook-automation/)
- [DrDroid - Runbook Template](https://drdroid.io/engineering-tools/runbook-template-best-practices-examples)
- [Full Scale - Technical Wiki](https://fullscale.io/blog/build-a-technical-wiki-engineers-actually-use/)

### 우리 환경에 대한 시사점

- 1인 개발이므로 Wiki 플랫폼 도입은 과함. **Git 리포의 Markdown이 Wiki 역할**
- "문서 무덤" 방지 핵심: **문서가 코드 옆에 존재** + **자동 신선도 체크** — 이미 부분적으로 실천 (CHANGELOG + pre-commit hook)
- Runbook 개념은 플러그인 운영에 적용 가능: "hook이 실패할 때", "plugin update 후 커맨드가 안 보일 때" 등의 트러블슈팅 가이드

---

## 2-5. AI 보조 개발 환경의 문서화

### AI 코딩 도구와 문서의 관계

**새로운 문서 유형의 등장**:

| 파일 | 도구 | 역할 |
|------|------|------|
| `CLAUDE.md` | Claude Code | 프로젝트 규칙, 코딩 표준, 아키텍처 결정 |
| `.cursor/rules/*.mdc` | Cursor | 경로별 코딩 규칙 |
| `.codex/AGENTS.md` | Codex | 에이전트 지시사항 |
| `AGENTS.md` | 범용 | 도구 독립적 AI 지시 (신규 컨벤션) |

이것들은 **"기계가 읽는 문서"** — 전통적 문서와 달리 AI 에이전트의 행동을 직접 제어.

**크로스 도구 규칙 관리**:
- 각 도구마다 다른 포맷 → 동기화 문제
- [ai-nexus](https://github.com/JSK9999/ai-nexus), [rulesync](https://dev.to/dyoshikawatech/rulesync-published-a-tool-to-unify-management-of-rules-for-claude-code-gemini-cli-and-cursor-390f) 같은 통합 도구 등장
- 경로별 규칙(path-specific rules): 관련 파일 작업 시에만 로딩 → 토큰 절약

**출처**: [steipete/agent-rules](https://github.com/steipete/agent-rules), [Cursor Docs - Rules](https://cursor.com/docs/context/rules)

### Vibe Coding과 문서화 위기

**Andrej Karpathy가 2025년 초 명명**한 "Vibe Coding":
- 자연어 프롬프트로 AI가 코드 생성, 개발자는 리뷰/가이드 역할
- **문제점**: CTO 18명 대상 설문에서 16명이 AI 생성 코드로 프로덕션 장애 경험 보고
- GitClear 분석: 2024년 **코드 중복 8배 증가**, 67%의 개발자가 AI 코드 디버깅에 더 많은 시간 소비
- METR 연구: 숙련 개발자가 AI 도구 사용 시 실제로는 **19% 느림** (체감은 20% 빠름)

**Addy Osmani의 AI 보조 개발 가이드** ([beyond.addy.ie](https://beyond.addy.ie/)):

효과적 패턴:
- **SPEC.md / mini-PRD 작성 후 구현** — AI에게 명확한 요구사항 제공
- **관련 문서를 AI 컨텍스트에 직접 투입** — knowledge cutoff 대응
- **글로벌 코딩 표준을 시스템 프롬프트로 설정** — 일관성 유지
- **점진적 테스트** — 변경마다 검증

위험한 패턴:
- 모호한 요청 ("Make it better")
- 컨텍스트 없이 코드 생성 요청
- 하나의 프롬프트에 과도한 복잡성
- AI가 프로젝트 맥락을 안다고 가정

### 5개 기존 사례에서 발견한 AI 시대 문서화 패턴

기존 분석(bkit, team-attention, 조아영, 마누스, 류장근)에서 일반화할 수 있는 패턴:

| 패턴 | 사례 | 일반 원칙 |
|------|------|-----------|
| **기계용/사람용 문서 분리** | bkit (.pdca-status.json vs 보고서 md) | JSON/YAML은 AI/자동화용, Markdown은 사람용 |
| **세션 간 연속성 메커니즘** | 조아영 (/wrap→/morning), team-attention (CLAUDE.md 축적) | AI 세션은 stateless → 명시적 핸드오프 문서 필수 |
| **결정 전 재참조 강제** | 마누스 ("plan 파일을 다시 읽어라") | CLAUDE.md 규칙으로 "X 전에 Y를 읽어라" 패턴 |
| **자동 문서 업데이트** | team-attention (doc-updater), bkit (hook 파이프라인) | 세션 종료 시 자동 문서 갱신 = 문서 부패 방지 |
| **피드백 루프** | 조아영 (RLHF식), bkit (Match Rate < 90% → 재시도) | 문서/규칙의 효과를 측정하고 점진 개선 |
| **극단적 단순성도 유효** | 마누스 (규칙 1개, 파일 3개) | 복잡한 시스템 없이도 핵심 문제(Goal Drift) 해결 가능 |

### 우리 환경에 대한 시사점

- **CLAUDE.md가 이미 ADR + 코딩 표준 + 런북의 역할을 겸하고 있음** — 이 역할들을 의식적으로 분리할 것인지가 핵심 결정
- **handoff 문서** = 세션 간 연속성 메커니즘. 이미 패턴 실천 중
- **Skills로 on-demand 로딩** = 토큰 절약을 위한 경로별 규칙의 자체 구현
- CLAUDE.md에 "왜(Why)" 기록이 부족할 수 있음 → 핵심 결정에 한해 ADR 스타일 섹션 추가 고려
- pre-commit hook의 version 검증 = SSOT 원칙의 실천적 구현

---

## 종합 — 우리 환경 적용 로드맵 (제안)

### 이미 잘 하고 있는 것

| 실천 항목 | 해당 개념 |
|-----------|-----------|
| CLAUDE.md + 프로젝트 CLAUDE.md | Docs-as-Code, 기계용 문서 |
| CHANGELOG.md (커밋마다 기록) | 변경 로그 SSOT |
| handoff/ 문서 | 세션 간 연속성 |
| plugin.json ↔ marketplace.json 일치 검증 | SSOT + 자동 검증 |
| Skills on-demand 로딩 | 토큰 최적화 |

### 추가하면 좋을 것

| 개선 항목 | 난이도 | 효과 |
|-----------|--------|------|
| 핵심 설계 결정에 ADR 추가 (`docs/decisions/`) | 낮음 | "왜" 기록으로 미래의 나를 도움 |
| CLAUDE.md의 역할 분리 (규칙 vs 결정 vs 트러블슈팅) | 낮음 | 가독성·검색성 향상 |
| 간단한 CI lint (markdownlint, link check) | 중간 | 문서 품질 자동 보장 |
| 플러그인별 트러블슈팅 가이드 (Runbook 경량 버전) | 낮음 | 반복 문제 자가 해결 |

### 하지 않아도 될 것

| 항목 | 이유 |
|------|------|
| SSG (MkDocs/Docusaurus) 도입 | 현재 규모에서 GitHub 렌더링으로 충분 |
| Wiki 플랫폼 (Notion/Confluence) | 1인 개발, Git 리포가 Wiki |
| API 문서화 도구 (Scalar/Redoc) | REST API 없음 |
| Log4brains 등 ADR 전용 도구 | Markdown 파일로 충분 |

---

## 출처 종합

### ADR
- [ADR GitHub](https://adr.github.io/)
- [MADR](https://adr.github.io/madr/)
- [Y-Statements (Olaf Zimmermann)](https://medium.com/olzzio/y-statements-10eb07b5a177)
- [AWS - ADR Best Practices](https://aws.amazon.com/blogs/architecture/master-architecture-decision-records-adrs-best-practices-for-effective-decision-making/)
- [Microsoft - ADR](https://learn.microsoft.com/en-us/azure/well-architected/architect-role/architecture-decision-record)
- [Adam Cogan - ADRs](https://adamcogan.com/2024/10/09/essential-role-of-architectural-decision-records/)
- [Log4brains](https://github.com/thomvaill/log4brains)
- [joelparkerhenderson/architecture-decision-record](https://github.com/joelparkerhenderson/architecture-decision-record)

### Docs-as-Code
- [TechTarget - Docs-as-Code Explained](https://www.techtarget.com/searchapparchitecture/tip/Docs-as-Code-explained-Benefits-tools-and-best-practices)
- [Kong - What is Docs as Code](https://konghq.com/blog/learning-center/what-is-docs-as-code)
- [Pinterest Engineering - Docs-as-Code](https://medium.com/pinterest-engineering/adopting-docs-as-code-at-pinterest-4f18ad169c25)
- [Squarespace Engineering - Docs-as-Code Journey](https://engineering.squarespace.com/blog/2025/making-documentation-simpler-and-practical-our-docs-as-code-journey)
- [MkDocs Material Alternatives](https://squidfunk.github.io/mkdocs-material/alternatives/)

### API 문서화
- [APIs You Won't Hate - Top 5 API Docs Tools 2025](https://apisyouwonthate.com/blog/top-5-best-api-docs-tools/)
- [Swagger - Code-First vs Design-First](https://swagger.io/blog/code-first-vs-design-first-api/)
- [Theneo - API Documentation Best Practices 2025](https://www.theneo.io/blog/api-documentation-best-practices-guide-2025)
- [Blog.noclocks.dev - Schema-Driven Development](https://blog.noclocks.dev/schema-driven-development-and-single-source-of-truth-essential-practices-for-modern-developers)

### Engineering Wiki / Runbook
- [DEV - Why Your Engineering Wiki is a Graveyard](https://dev.to/kislay/why-your-engineering-wiki-is-a-graveyard-and-how-to-fix-it-2eme)
- [Full Scale - Technical Wiki](https://fullscale.io/blog/build-a-technical-wiki-engineers-actually-use/)
- [IncidentHub - Runbook Best Practices](https://blog.incidenthub.cloud/The-No-Nonsense-Guide-to-Runbook-Best-Practices)
- [Engini - Runbook Automation 2025](https://engini.io/blog/runbook-automation/)
- [GitBook Blog - Confluence Alternatives](https://www.gitbook.com/blog/confluence-alternatives)

### AI 보조 개발
- [Addy Osmani - Beyond Vibe Coding](https://beyond.addy.ie/)
- [Google Cloud - Vibe Coding](https://cloud.google.com/discover/what-is-vibe-coding)
- [Wikipedia - Vibe Coding](https://en.wikipedia.org/wiki/Vibe_coding)
- [steipete/agent-rules](https://github.com/steipete/agent-rules)
- [Cursor Docs - Rules](https://cursor.com/docs/context/rules)
- [Vladimir Siedykh - AI Coding Assistant Comparison](https://vladimirsiedykh.com/blog/ai-coding-assistant-comparison-claude-code-github-copilot-cursor-feature-analysis-2025)
- [Graphite - Programming with AI](https://graphite.com/guides/programming-with-ai-workflows-claude-copilot-cursor)
