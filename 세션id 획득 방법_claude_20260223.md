> From: https://claude.ai/chat/0851ce56-9d20-415f-953b-d370f0674dd1

# you asked

클로드코드 플러그인 oh my claudecode화면이다. 하단 statusline에서 task별 진척도를 claude herd(?)라는 리포지토리에서 가져와서 적용한 것이라고 한다. 내용을 확인해달라. 팩트체크

---

# claude response

"claude herd"로는 직접 안 나온다. 스크린샷을 더 면밀히 보면 **"trawork"**라는 프로젝트명이 보이고, 하단에 5개 agents가 병렬 실행되는 구조다. "Oh My ClaudeCode(OMC)"와 관련된 멀티에이전트 오케스트레이션 도구를 찾아보겠다.

이제 "claude herd"라는 이름의 리포지토리를 별도로 확인해보겠다.

팩트체크 결과:

## 스크린샷 분석

**"claude herd"라는 별도 리포지토리는 존재하지 않는다.** 검색 결과 해당 이름의 GitHub 리포지토리는 확인되지 않음.

## 실제 정체: Oh My ClaudeCode (OMC)의 Team 모드 + HUD

스크린샷에 보이는 것은 모두 **Oh My ClaudeCode (OMC)** 플러그인의 기능이다:

| 요소 | 설명 |
|---|---|
| `[OMC]` 표시 | Oh My ClaudeCode 플러그인 HUD statusline |
| `agents:5` | OMC의 Team 모드로 5개 에이전트 병렬 실행 |
| `W1~W5` | Worker 1~5, 각각 독립 태스크에 할당된 서브에이전트 |
| `trawork` | 작업 중인 프로젝트명 |
| `ctx:20%` | 컨텍스트 윈도우 사용률 |
| `~$0.2072`, `$2.96/h` | OMC의 실시간 비용 추적 |
| `bypass permissions on · 5 background tasks` | Claude Code 네이티브 Team/Agent 기능 활용 |
| 상단 `#2~#6` 체크리스트 | Team 모드의 태스크 분해 결과 (plan → exec 파이프라인) |

## 핵심 정리

"claude herd"는 잘못된 정보이거나 오해다. 이 화면은 **OMC(`oh-my-claudecode`)의 Team 모드**가 Claude Code 네이티브 Agent Teams 기능 위에서 5개 워커를 병렬 실행하는 것이며, 리포지토리는 `github.com/Yeachan-Heo/oh-my-claudecode` 하나뿐이다. HUD statusline, 비용 추적, 워커별 진척 표시 모두 OMC 플러그인 내장 기능이다.

---

# you asked

그건 맞다. 다만 hud statusline에 task 병렬처리 현황을 보여주는 레포는 없나? 또는 방법은 없나?

---

# claude response

찾았다. "claude herd"가 아니라 **"claude-hud"**다. 발음/필기 오인이었을 가능성이 높다.

## 정정: "claude herd" → **claude-hud**

스크린샷의 statusline에서 task별 병렬 진척도를 보여주는 기능은 **`claude-hud`** 플러그인이다.

### claude-hud (`jarrodwatts/claude-hud`)

| 항목 | 내용 |
|---|---|
| 리포 | [github.com/jarrodwatts/claude-hud](https://github.com/jarrodwatts/claude-hud) |
| 기능 | context 사용률, 활성 도구, 실행 중 에이전트, todo 진척도를 statusline에 실시간 표시 |
| 원리 | Claude Code의 네이티브 statusline API를 사용, transcript JSONL 파싱으로 ~300ms 주기 업데이트 |
| 설치 | Claude Code 내에서 3줄로 끝남 |

### 그런데 스크린샷은 claude-hud가 아니라 OMC의 HUD

스크린샷에 `[OMC]`가 찍혀 있으므로, 실제로는 **OMC 자체 내장 HUD**가 표시한 것이다. OMC도 자체 `/oh-my-claudecode:hud` 스킬로 유사한 statusline을 제공한다. 차이점:

| | claude-hud | OMC HUD |
|---|---|---|
| 성격 | 독립 플러그인 (모니터링 전용) | OMC 오케스트레이션에 포함된 부속 기능 |
| 에이전트 추적 | 네이티브 서브에이전트 표시 | OMC Team 모드의 W1~W5 워커 진척 + 비용 추적 |
| 비용 표시 | 없음 (Enhanced 포크에서 일부) | `$0.2072`, `$2.96/h` 등 실시간 비용 |
| 설치 | 별도 플러그인 | OMC 설치 시 자동 포함 |

### So What?

병욱님이 원하는 **"task별 병렬처리 현황을 statusline에 표시"**하려면 두 가지 경로가 있다:

1. **OMC 전체 사용** → Team 모드 + 내장 HUD로 스크린샷과 동일한 경험. 다만 OMC 전체 오케스트레이션 레이어를 수용해야 함
2. **claude-hud 단독 사용** → 가볍게 모니터링만. Claude Code 네이티브 Agent Teams로 병렬 실행하고, claude-hud가 에이전트 상태/todo 진척을 표시. 오케스트레이션 로직 없이 순수 "계기판" 역할

가벼운 모니터링만 원하면 claude-hud, 오케스트레이션까지 원하면 OMC가 맞다.

---

# you asked

claude hud에서 꼭 네이티브 서브에이전트가 아니라 내가 따로 제작한 서브에이전트는 안보이는 건가?

---

# claude response

GitHub 렌더링이 안 됐다. 소스 코드를 직접 확인하겠다.

**커스텀 서브에이전트도 보인다.**

claude-hud는 에이전트 감지를 Claude Code의 **transcript JSONL 파일**을 파싱해서 수행한다. 구체적으로:

### 감지 원리

claude-hud는 세션의 transcript JSONL에서 `Task` tool_use 블록을 파싱한다. Claude Code가 서브에이전트를 실행하면 빌트인이든 커스텀이든 모두 `Task` 도구를 통해 호출되고, 이 호출이 transcript에 기록된다. claude-hud의 agents-line 렌더러는 이 기록에서 에이전트 타입, 모델, 설명, 경과 시간을 추출해서 표시한다.

출력 예시:
```
◐ explore [haiku]: Finding auth code (2m 15s)
◐ my-custom-agent [sonnet]: Analyzing requirements (1m 30s)
```

### 즉, 커스텀 에이전트가 보이려면

1. **`~/.claude/agents/` 또는 `.claude/agents/`에 정의한 커스텀 에이전트**가 `Task` 도구를 통해 실제로 실행되어야 함
2. 실행되면 transcript에 `tool_use` → `subagent_type: "your-agent-name"` 형태로 기록됨
3. claude-hud가 이걸 파싱해서 statusline에 표시

### 주의점

커스텀 에이전트가 Claude Code에 의해 **실제로 인식되고 호출되는 것이 전제**다. 앞서 검색에서 나온 것처럼, `~/.claude/agents/`에 수동으로 만든 커스텀 에이전트가 로딩되지 않는 버그가 보고되어 있다(Issue #11205, #20931). UI로 만든 에이전트는 정상 동작하지만 파일로 수동 생성한 경우 인식이 안 되는 케이스가 있으므로, 커스텀 에이전트가 `Task`로 정상 호출되는지 먼저 확인해야 한다. 호출만 되면 claude-hud에는 자동으로 보인다.

---

# you asked

좋다. 이건 다른 질문이다. 세션기록을 jsonl로 저장한다고 안다. 세션기록의 고유id. 예를 들면 파일명에 들어가는 세션 아이디 같은 것도 실시간으로 조회할 수 있나? 있다면 그 방법은?

---

# claude response

**가능하다.** 여러 방법이 있다.

## 현재 세션 ID 실시간 조회 방법

### 1. Statusline stdin JSON (가장 직접적)

Claude Code가 statusline 플러그인에 ~300ms마다 전달하는 stdin JSON에 **`session_id`가 이미 포함**되어 있다. Issue #18022에서 확인된 구조:

```json
{
  "session_id": "abc123-...",
  "model": {...},
  "context_window": {...},
  "cost": {...}
}
```

따라서 claude-hud 같은 statusline 플러그인을 쓰거나, 직접 커스텀 statusline 스크립트를 만들면 `session_id`를 실시간으로 읽을 수 있다.

### 2. Hook에서 추출

`stop` 또는 `subagent_stop` hook이 실행될 때 전달되는 JSON 데이터에도 `session_id`와 `transcript_path`가 포함된다:

```bash
HOOK_DATA=$(cat)
SESSION_ID=$(echo "$HOOK_DATA" | jq -r '.session_id // "unknown"')
TRANSCRIPT_PATH=$(echo "$HOOK_DATA" | jq -r '.transcript_path // empty')
```

매 턴마다 발생하므로 사실상 실시간이다.

### 3. 파일시스템에서 직접 확인

세션 파일 경로: `~/.claude/projects/<url-encoded-project-path>/sessions/<session-uuid>.jsonl`

현재 작업 디렉토리에서 가장 최근 수정된 JSONL 파일이 현재 세션:

```bash
ls -t ~/.claude/projects/<project-path>/sessions/*.jsonl | head -1
```

### 4. history.jsonl에서 조회

`~/.claude/history.jsonl`에 모든 프롬프트 입력이 session ID와 함께 기록되므로, 마지막 항목을 읽으면 현재 세션 ID를 얻을 수 있다.

### So What?

**가장 깔끔한 방법은 1번(statusline)**이다. 별도 코드 없이 claude-hud를 쓰면 이미 session_id에 접근 가능한 파이프라인 위에 있고, 커스텀 statusline을 만들면 `stdin`에서 `session_id`를 파싱해 원하는 형태로 표시할 수 있다. Hook 방식(2번)은 세션 종료/턴 완료 시점에 다른 자동화(로깅, 백업 등)와 연계하기 좋다.

---

# you asked

사실 보통 세션 마무리할 때 세션 wrap이라는 커스텀 플러그인을 쓰면서 handoff.md파일을 작성하게 하고 있다. 그런데 이 문서에 세션id를 포함하게 하고 싶다.

---

# claude response

실용적인 접근이다. handoff.md에 session_id를 넣으려면 **wrap 플러그인이 실행되는 시점에 session_id를 어떻게 가져오느냐**가 핵심이다.

## 방법별 비교

| 방법 | 구현 | 신뢰도 | 비고 |
|---|---|---|---|
| **Bash로 history.jsonl 마지막 줄 파싱** | `tail -1 ~/.claude/history.jsonl \| jq -r '.sessionId'` | ★★★ | 가장 간단. wrap 슬래시 커맨드 내에서 Bash 호출 가능 |
| **현재 CWD 기준 최신 JSONL 파일명** | `ls -t ~/.claude/projects/.../sessions/*.jsonl \| head -1` | ★★☆ | 멀티세션 시 오인 가능 |
| **Hook 연계** | stop hook에서 session_id를 파일로 저장 → wrap에서 읽기 | ★★★ | 정확하지만 사전 설정 필요 |

## 가장 현실적인 구현

wrap 커맨드(슬래시 커맨드 또는 스킬) 안에서 Claude Code에게 Bash 도구로 session_id를 추출하게 하면 된다. wrap 커맨드의 프롬프트에 이런 식으로 지시를 추가:

```
handoff.md 작성 전에 먼저 아래 명령으로 현재 세션 ID를 확인하라:
  tail -1 ~/.claude/history.jsonl | jq -r '.sessionId'
확인된 세션 ID를 handoff.md 상단 메타데이터에 포함하라.
```

handoff.md 출력 형태:

```markdown
# Handoff - 2026-02-23

- **Session ID**: `a1b2c3d4-e5f6-7890-abcd-ef1234567890`
- **Project**: /home/user/my-project
- **Duration**: ~45min

## 작업 내용
...
```

기존 wrap 플러그인의 프롬프트에 위 지시문만 추가하면 되므로, 코드 수정 없이 프롬프트 레벨에서 해결된다. 별도 hook 세팅도 불필요하다.

---

# you asked

여러개 클로드코드 세션을 쓰는 경우가 많다. 1번 방법은 해당 세션 아이디를 보장하는가? 3번은 스탑훅이라는 것이 뭔가 조금 더 로직을 쉽게 설먕하라

---

# claude response

좋은 지적이다.

## 1번 방법 (history.jsonl tail) — 멀티세션에서 불안정

`history.jsonl`은 **모든 세션이 공유하는 단일 파일**이다. 세션 A에서 wrap을 실행하는 사이에 세션 B에서 프롬프트를 입력하면, `tail -1`이 세션 B의 ID를 반환한다. **멀티세션에서 현재 세션 ID를 보장하지 못한다.**

## 3번 방법 (Hook) — 쉽게 설명

Hook의 로직은 이렇다:

1. Claude Code는 매 턴이 끝날 때마다 **자동으로** hook 스크립트를 실행한다
2. 이때 Claude Code가 hook에 **현재 세션의 정보(session_id, transcript_path 등)를 JSON으로 넘겨준다**
3. hook 스크립트가 그 session_id를 **프로젝트 폴더의 임시 파일에 저장**한다
4. wrap 실행 시 그 파일을 읽으면 **확실히 해당 세션의 ID**다

핵심은 Claude Code가 hook을 호출할 때 **"나는 이 세션이다"라고 스스로 알려준다**는 점이다. 외부에서 추측할 필요가 없다.

## 멀티세션에서 확실한 방법: Hook + 프로젝트별 파일

설정은 `~/.claude/settings.json`에 한 줄 추가:

```json
{
  "hooks": {
    "stop": [{
      "type": "command",
      "command": "echo $CLAUDE_SESSION_ID > .claude/.current-session-id"
    }]
  }
}
```

> 환경변수가 아닌 stdin JSON 방식이라면:
> `"command": "cat | jq -r '.session_id' > .claude/.current-session-id"`

이렇게 하면 **각 프로젝트 폴더의 `.claude/.current-session-id`에 해당 세션 ID가 매 턴마다 갱신**된다. 세션 A는 프로젝트 A 폴더에, 세션 B는 프로젝트 B 폴더에 각각 쓰므로 충돌이 없다.

wrap 커맨드 프롬프트에는:

```
handoff.md 작성 전에 cat .claude/.current-session-id로 현재 세션 ID를 읽어서 메타데이터에 포함하라.
```

이게 멀티세션에서 가장 신뢰할 수 있는 방법이다.

---

# you asked

환경변수가 아닌 stdin JSON 방식이라면:
두 방식의 차이는?

---

# claude response

## 두 방식의 차이

| | 환경변수 방식 | stdin JSON 방식 |
|---|---|---|
| **데이터 전달** | Claude Code가 hook 실행 시 `$CLAUDE_SESSION_ID` 같은 환경변수를 세팅해줌 | Claude Code가 hook 프로세스의 **표준입력(stdin)**으로 JSON 덩어리를 보내줌 |
| **예시** | `echo $CLAUDE_SESSION_ID` | `cat \| jq -r '.session_id'` |
| **가용 정보** | 변수명별로 개별 접근 | session_id, transcript_path, cost 등 한꺼번에 들어옴 |

## 실제로 어느 쪽인가

여기서 솔직히 말하면, **Claude Code의 hook이 정확히 어떤 방식으로 session_id를 전달하는지 내가 100% 확신하지 못한다.** 앞서 검색한 자료들에서는 stdin JSON 방식이 확인됐고(`jq -r '.session_id'`, `jq -r '.transcript_path'`), 환경변수 `$CLAUDE_SESSION_ID`는 공식 문서에서 명시적으로 확인하지 못했다.

따라서 **stdin JSON 방식이 확인된 방법**이다:

```json
{
  "hooks": {
    "stop": [{
      "type": "command",
      "command": "cat | jq -r '.session_id' > .claude/.current-session-id"
    }]
  }
}
```

실제 적용 전에 `cat | tee /tmp/hook-debug.json`으로 hook에 들어오는 데이터를 한번 찍어보면 정확한 필드명을 확인할 수 있다.

---

# you asked

여기서 솔직히 말하면, Claude Code의 hook이 정확히 어떤 방식으로 session_id를 전달하는지 내가 100% 확신하지 못한다 => 이를 검증하고 싶다. 어떻게 하면 될까?

---

# claude response

가장 간단한 방법: **hook에 들어오는 데이터를 그대로 파일로 덤프**하면 된다.

## 검증 절차

### Step 1. 덤프용 hook 설정

`~/.claude/settings.json`에 추가:

```json
{
  "hooks": {
    "stop": [{
      "type": "command",
      "command": "cat > /tmp/claude-hook-dump.json"
    }]
  }
}
```

`cat`이 stdin으로 들어오는 데이터를 **전부** 파일로 저장한다.

### Step 2. Claude Code에서 아무 작업 한 턴 수행

간단한 질문이면 충분하다. 턴이 끝나면 hook이 자동 실행된다.

### Step 3. 덤프 확인

```bash
cat /tmp/claude-hook-dump.json | jq .
```

이러면 Claude Code가 hook에 **실제로 어떤 필드를 넘기는지** 전부 보인다. `session_id`가 있는지, 필드명이 `session_id`인지 `sessionId`인지, 환경변수도 같이 오는지 등을 한번에 확인할 수 있다.

### Step 4. 환경변수도 같이 확인하고 싶다면

```json
{
  "hooks": {
    "stop": [{
      "type": "command",
      "command": "echo '---STDIN---' > /tmp/claude-hook-dump.txt && cat >> /tmp/claude-hook-dump.txt && echo '---ENV---' >> /tmp/claude-hook-dump.txt && env | grep -i claude >> /tmp/claude-hook-dump.txt"
    }]
  }
}
```

이러면 stdin JSON과 환경변수 양쪽 다 한 파일에 찍힌다. 5분이면 끝난다.