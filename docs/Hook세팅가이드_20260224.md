# Claude Code Hook 세팅 가이드 (초보자용)

> 작성일: 2026-02-24
> 대상: Claude Code 플러그인을 처음 만드는 개발자
> 기반: my-claude-plugins 프로젝트의 실전 디버깅 경험

---

## 한눈에 보기

| 주제 | 핵심 | 섹션 |
|------|------|:---:|
| **Hook 개념** | 이벤트(SessionStart 등)에 반응하는 자동 실행 스크립트 | §1 |
| **hooks.json** | 이중 배열 구조 `[{ hooks: [{ type, command }] }]` — 빠뜨리면 조용히 미실행 | §2 |
| **stdin 데이터** | 모든 이벤트에 `session_id`, `cwd`, `transcript_path` 포함 (JSON) | §3 |
| **세션 ID 캡처** | SessionStart hook → `cwd/.claude/.current-session-id`에 저장 (20줄) | §4 |
| **커맨드 자동 등록** | `plugin:` frontmatter 마커로 충돌 감지 | §5 |
| **디버깅** | 파일 생성으로 실행 확인. "hook success" ≠ command 실행 | §6 |
| **Windows 필수** | bash 스크립트 불가 → **Node.js만 사용** | §6, §8 |

**Common Error 7개**: 이벤트명 오타 · 배열 중첩 누락 · 빈 stdin crash · 글로벌 경로 충돌 · 마커 형식 오류 · Windows bash 불가 · hook success 오해

---

## 1. Hook이란?

Claude Code가 특정 **이벤트**에 반응하여 자동 실행하는 스크립트. 세션이 시작될 때 초기화하거나, 사용자 입력마다 로깅하는 등의 자동화에 사용한다.

### 주요 이벤트

| 이벤트 | 발동 시점 | 대표 용도 |
|--------|---------|----------|
| **SessionStart** | 세션 시작 (새 창, resume) | 초기화, 커맨드 등록, 세션 ID 캡처 |
| **UserPromptSubmit** | 사용자가 프롬프트 전송할 때마다 | 입력 로깅, 상태 업데이트 |
| **Stop** | AI 응답 완료 또는 사용자 중단 | 결과 후처리, 세션 종료 기록 |
| **PreToolUse** | 도구 실행 직전 | 위험 명령 차단 |
| **PostToolUse** | 도구 실행 직후 | 결과 검증 |

> **⚠️ Common Error: 이벤트명 오타**
> `sessionStart`(소문자 s)로 쓰면 조용히 무시된다. 정확히 `SessionStart`(PascalCase).

---

## 2. hooks.json 구조

플러그인의 `hooks/hooks.json`에 정의한다. **이중 배열 구조**가 핵심이다.

### 최소 예제

```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/my-script.js\"",
            "timeout": 3000
          }
        ]
      }
    ]
  }
}
```

### 구조 해부

```
hooks                          ← 최상위 객체
  └─ SessionStart              ← 이벤트명
       └─ [ { hooks: [...] } ] ← 배열 안에 배열 (이중 구조!)
              └─ { type, command, timeout }  ← 실제 실행 정의
```

| 필드 | 설명 | 필수 |
|------|------|:---:|
| `type` | `"command"` (현재 유일한 옵션) | ✅ |
| `command` | 실행할 명령. `${CLAUDE_PLUGIN_ROOT}`로 플러그인 루트 경로 참조 | ✅ |
| `timeout` | 타임아웃 ms. 기본값이 불명확하므로 명시 권장 | ❌ |
| `matcher` | `"startup"` → 새 세션 시작 시에만 1회 실행. 생략 시 매번 발동 | ❌ |

### matcher 사용 예시

```json
"SessionStart": [
  {
    "matcher": "startup",
    "hooks": [{ "type": "command", "command": "node ... ensure-commands.js" }]
  },
  {
    "hooks": [{ "type": "command", "command": "node ... capture-session-id.js" }]
  }
]
```
- 첫 번째: `matcher: "startup"` → 세션당 1회 (커맨드 등록)
- 두 번째: matcher 없음 → startup + resume 모두 발동 (세션 ID 캡처)

> **⚠️ Common Error: 배열 중첩 빠뜨림**
> 가장 흔한 실수. hook이 등록은 되지만 **조용히 실행되지 않는다.**
> ```json
> // ❌ 잘못된 구조
> "SessionStart": [
>   { "type": "command", "command": "..." }
> ]
>
> // ✅ 올바른 구조 (hooks 배열로 한 번 더 감싸야 함)
> "SessionStart": [
>   { "hooks": [{ "type": "command", "command": "..." }] }
> ]
> ```

---

## 3. stdin 데이터

Hook이 실행될 때 Claude Code가 **stdin으로 JSON 데이터를 전달**한다.

### 실측 데이터 (SessionStart)

```json
{
  "session_id": "250802d8-d969-4006-81f1-1850e9e79f19",
  "transcript_path": "C:\\Users\\...\\250802d8-....jsonl",
  "cwd": "C:\\Users\\ahnbu\\.claude\\my-claude-plugins",
  "hook_event_name": "SessionStart",
  "source": "startup",
  "model": "claude-opus-4-6"
}
```

### 이벤트별 필드 비교

| 필드 | SessionStart | UserPromptSubmit | Stop |
|------|:---:|:---:|:---:|
| `session_id` | ✅ | ✅ | ✅ |
| `transcript_path` | ✅ | ✅ | ✅ |
| `cwd` | ✅ | ✅ | ✅ |
| `hook_event_name` | ✅ | ✅ | ✅ |
| `model` | ✅ | ❌ | ❌ |
| `source` | ✅ | ❌ | ❌ |
| `permission_mode` | ❌ | ✅ | ✅ |
| `prompt` | ❌ | ✅ | ❌ |
| `last_assistant_message` | ❌ | ❌ | ✅ |

### Node.js에서 stdin 읽기

```javascript
let input = "";
process.stdin.on("data", (chunk) => { input += chunk; });
process.stdin.on("end", () => {
  if (!input) return;           // ← 빈 stdin 방어
  try {
    const data = JSON.parse(input);
    const { session_id, cwd } = data;
    // 여기서 처리...
  } catch (_) {
    // 조용히 실패 (hook이 세션을 방해하면 안 됨)
  }
});
```

> **⚠️ Common Error: 빈 stdin에서 crash**
> `if (!input) return;`을 빠뜨리면 `JSON.parse("")`가 예외를 던진다.
> 반드시 try-catch와 빈 값 체크를 함께 사용하라.

---

## 4. 실전: 세션 ID 캡처

### 왜 필요한가

- Handoff 문서에 세션 추적 정보 기재
- JSONL 트랜스크립트 연결
- 디버깅 시 세션 식별

### capture-session-id.js (실제 프로덕션 코드)

```javascript
#!/usr/bin/env node
const fs = require("fs");
const path = require("path");

let input = "";
process.stdin.on("data", (chunk) => { input += chunk; });

process.stdin.on("end", () => {
  if (!input) return;
  try {
    const data = JSON.parse(input);
    const { session_id, cwd } = data;
    if (session_id && cwd) {
      const dest = path.join(cwd, ".claude", ".current-session-id");
      fs.mkdirSync(path.dirname(dest), { recursive: true });
      fs.writeFileSync(dest, session_id);
    }
  } catch (_) {}
});
```

**핵심 포인트:**
- `cwd` 기준 프로젝트 폴더에 저장 → 동시 세션 안전
- `mkdirSync({ recursive: true })` → `.claude/` 폴더 없어도 자동 생성
- 20줄 미만의 단순한 코드 — hook 스크립트는 이 정도로 충분

### hooks.json 등록

```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\"",
            "timeout": 3000
          }
        ]
      }
    ]
  }
}
```

> **⚠️ Common Error: 글로벌 경로에 저장**
> `~/.claude/.current-session-id`처럼 글로벌 경로를 쓰면, 동시에 열린 세션이 서로 덮어쓴다.
> 반드시 `cwd` (프로젝트 폴더) 기준으로 저장하라.

### 세션 ID 대안 획득법 (JSONL 파일명)

hook이 실패하더라도 세션 ID를 얻는 방법이 있다:

```bash
ls -t ~/.claude/projects/<encoded-cwd>/*.jsonl | head -1 | xargs basename | sed 's/.jsonl//'
```

JSONL 파일명 자체가 세션 ID이므로, 가장 최근 수정 파일 = 현재 세션.

---

## 5. 실전: 커맨드 자동 등록

SessionStart hook의 대표 패턴. 플러그인의 `commands/*.md` 파일을 `~/.claude/commands/`에 자동 복사한다.

### ensure-commands.js 핵심 로직

```javascript
const PLUGIN_NAME = "my-plugin";
const PLUGIN_MARKER = `plugin: ${PLUGIN_NAME}`;

// 각 커맨드 파일에 대해:
if (!fs.existsSync(dest)) {
  fs.copyFileSync(src, dest);      // 없으면 설치
} else {
  const destContent = fs.readFileSync(dest, "utf8");
  if (destContent.includes(PLUGIN_MARKER)) {
    if (srcContent !== destContent)
      fs.copyFileSync(src, dest);   // 내 파일이면 갱신
  } else {
    skipped.push(commandName);      // 남의 파일이면 스킵
  }
}
```

### 충돌 감지: frontmatter 마커

커맨드 파일에 반드시 `plugin:` 마커를 넣어야 한다:

```markdown
---
plugin: my-plugin
---
# /my-command
...
```

> **⚠️ Common Error: 마커 누락 또는 형식 오류**
> - 마커 없으면 → 다른 플러그인이 같은 이름의 커맨드를 덮어쓸 수 있음
> - `plugin:my-plugin` (공백 없음) → `includes()` 매칭 실패. **콜론 뒤 공백 필수**

---

## 6. 디버깅 가이드

### hook 실행 확인법

가장 확실한 방법: **파일 생성으로 확인**

```javascript
// capture-session-id.js — stdin 수신 완료 후 디버그 파일 생성
process.stdin.on("end", () => {
  fs.writeFileSync("/tmp/hook-debug.txt",
    `EXECUTED: ${new Date().toISOString()}\nSTDIN: ${input}\n`);
  // ... 이하 원래 로직
});
```

이 파일이 생성되면 hook이 실행된 것, 안 되면 hook 자체가 발동하지 않은 것.

### 실제 디버깅 사례: 세션 ID 미캡처

우리 프로젝트에서 겪은 문제의 디버깅 과정:

| 단계 | 확인 | 결과 |
|------|------|------|
| 1 | 시스템 리마인더에 "hook success" 출력? | ✅ 나옴 |
| 2 | 디버그 파일 생성? | ❌ 미생성 |
| 3 | 스크립트 수동 실행 (`echo '...' \| bash script.sh`) | ✅ 정상 동작 |
| 4 | Node.js hook (`ensure-commands.js`) 동작? | ✅ 정상 |
| **결론** | **bash 스크립트는 Windows에서 실행 불가** | Node.js로 전환하여 해결 |

**교훈**: `"hook success"` 메시지는 이벤트 처리를 의미하지, command의 실제 실행 성공이 아니다.

> **⚠️ Common Error: Windows에서 bash 스크립트 사용**
> Claude Code의 hook 실행기는 Windows에서 `cmd.exe`를 통해 프로세스를 spawn한다.
> `.sh` 파일의 shebang(`#!/bin/bash`)을 해석하지 못하므로, **반드시 Node.js 스크립트를 사용**하라.
> ```json
> // ❌ Windows에서 실패
> "command": "bash \"${CLAUDE_PLUGIN_ROOT}/hooks/script.sh\""
>
> // ✅ 크로스 플랫폼 동작
> "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/script.js\""
> ```

---

## 7. 체크리스트

새 hook을 만들 때 아래를 점검하라:

| # | 항목 | 확인 |
|---|------|:---:|
| 1 | hooks.json이 이중 배열 구조인가? (`[{ hooks: [{ type, command }] }]`) | ☐ |
| 2 | 이벤트명이 PascalCase인가? (`SessionStart`, `Stop` 등) | ☐ |
| 3 | command가 `node "..."` 형식인가? (bash 스크립트 ❌) | ☐ |
| 4 | `${CLAUDE_PLUGIN_ROOT}` 경로가 올바른가? | ☐ |
| 5 | `timeout`이 명시되어 있는가? (권장: 3000ms) | ☐ |
| 6 | stdin 빈 값 + JSON 파싱 실패를 방어하는가? (`if (!input) return` + try-catch) | ☐ |
| 7 | 파일 저장 시 `cwd` 기준인가? (글로벌 경로 ❌) | ☐ |
| 8 | 커맨드 파일에 `plugin: <name>` 마커가 있는가? (콜론 뒤 공백 확인) | ☐ |
| 9 | hook이 실패해도 세션을 차단하지 않는가? (`process.exit(1)` 지양, stderr 최소화) | ☐ |
| 10 | `/plugin update` 후 새 세션에서 테스트했는가? | ☐ |

---

## 8. 스크립트 언어 선택: .sh vs .js

### Hook에서 bash가 안 되는 이유

Claude Code의 hook 실행기는 Node.js `child_process`를 통해 프로세스를 spawn한다. **Windows에서는 기본 셸이 `cmd.exe`**이므로:

- `cmd.exe`는 `.sh` 파일의 shebang(`#!/bin/bash`)을 해석하지 못함
- `bash` 명령이 `cmd.exe`의 PATH에 없을 수 있음 (MSYS/Git Bash 전용)
- `node`는 Windows 네이티브 실행 파일이므로 `cmd.exe`에서도 정상 실행

### Bash 도구에서는 문제없다

Claude Code의 **Bash 도구**(에이전트·커맨드·스킬에서 호출)는 MSYS/Git Bash 셸 안에서 실행되므로 `.sh` 파일이 정상 동작한다. 문제는 **hook의 command 필드에서만** 발생한다.

| 실행 경로 | 셸 환경 | `.sh` 동작 |
|-----------|---------|:---:|
| hooks.json `command` | cmd.exe (Windows) | ❌ |
| Bash 도구 (스킬·에이전트 등) | MSYS/Git Bash | ✅ |
| 터미널 직접 실행 | 사용자 셸 | ✅ |

### 설치된 플러그인 실태 조사

실제로 설치된 플러그인들의 hook 스크립트를 언어별로 집계한 결과:

| 형식 | 개수 | 대표 플러그인 |
|------|:---:|----------|
| `.js` (Node.js) | **15개** | my-session-wrap, bkit, my-cowork |
| `.sh` (Bash) | **6개** | doubt, ralph-loop, explanatory-output-style |
| `.py` (Python) | **5개** | hookify, security-guidance, say-summary |

`.sh`를 사용하는 6개 플러그인은 macOS/Linux 전용으로, **Windows에서는 실행되지 않는다.** 크로스 플랫폼을 고려한 bkit은 100% Node.js만 사용한다.

### 실제 사례: 글로벌 hook 전환

`~/.claude/settings.json`의 `post-git-init-gitignore.sh`(bash)가 Windows에서 미동작하여 Node.js로 전환한 사례:

**변경 전 (미동작):**
```json
"command": "bash ~/.claude/hooks/post-git-init-gitignore.sh",
"timeout": 10
```

**변경 후 (동작 확인):**
```json
"command": "node ~/.claude/hooks/post-git-init-gitignore.js",
"timeout": 3000
```

timeout도 10ms → 3000ms로 수정. 10ms는 JSON 파싱 + 파일 I/O에 너무 짧다.

### 결론

**hook 스크립트는 Node.js(.js)로 작성하라.** bash/python은 macOS/Linux에서만 동작하며, Windows 호환이 보장되지 않는다.

---

## 참고 파일

| 항목 | 경로 |
|------|------|
| 세션 ID 캡처 (심플) | `my-session-wrap/hooks/capture-session-id.js` |
| 세션 ID 캡처 (이벤트별) | `my-session-id/hooks/capture-session-id.js` |
| 커맨드 자동 등록 | `my-session-wrap/hooks/ensure-commands.js` |
| hooks.json 예시 (matcher) | `my-session-wrap/hooks/hooks.json` |
| hooks.json 예시 (3이벤트) | `my-session-id/hooks/hooks.json` |
| 디버깅 기록 | `docs/my-session-wrap/session-id-capture-investigation.md` |
| stdin 실측 데이터 | `세션ID테스트_1차_훅실측_20260224.md` |
