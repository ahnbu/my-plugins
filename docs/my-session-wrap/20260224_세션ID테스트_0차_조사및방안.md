# Session ID 확보 방안 — 조사·테스트·결론

> 작성일: 2026-02-24
> 목적: my-session-wrap의 handoff 문서에 세션 ID를 포함하기 위한 최적 hook 선정
> 결론: **UserPromptSubmit** 채택

---

## 1. 배경

my-session-wrap 플러그인에서 `/wrap` 실행 시 생성하는 handoff 문서에 세션 ID를 포함하려 했으나, 기존 SessionStart hook 기반 `capture-session-id.sh`가 동작하지 않았다. 3개 hook(SessionStart, Stop, UserPromptSubmit)을 실측 테스트하여 최적의 hook을 선정한다.

---

## 2. Claude Code 공식 Hook 이벤트 전체 (17개)

### 세션 생명주기

| Hook | 발동 시점 | matcher |
|------|-----------|---------|
| **SessionStart** | 세션 시작/재개 | `source`: startup, resume, clear, compact |
| **SessionEnd** | 세션 종료 | `reason`: clear, logout, prompt_input_exit 등 |

### 사용자 입력

| Hook | 발동 시점 | matcher |
|------|-----------|---------|
| **UserPromptSubmit** | 프롬프트 제출 직후, AI 처리 전 | 미지원 |

### 도구 실행

| Hook | 발동 시점 | matcher |
|------|-----------|---------|
| **PreToolUse** | 도구 파라미터 생성 후, 실행 전 | `tool_name` |
| **PermissionRequest** | 권한 다이얼로그 표시 시 | `tool_name` |
| **PostToolUse** | 도구 실행 성공 후 | `tool_name` |
| **PostToolUseFailure** | 도구 실행 실패 시 | `tool_name` |

### 에이전트 턴

| Hook | 발동 시점 | matcher |
|------|-----------|---------|
| **Stop** | 메인 에이전트 응답 완료 (인터럽트 제외) | 미지원 |
| **SubagentStart** | 서브에이전트 생성 | `agent_type` |
| **SubagentStop** | 서브에이전트 완료 | `agent_type` |

### 기타

| Hook | 발동 시점 | matcher |
|------|-----------|---------|
| **Notification** | 알림 발생 | `notification_type` |
| **TaskCompleted** | 태스크 완료 표시 | 미지원 |
| **ConfigChange** | 설정 파일 변경 | `source` |
| **WorktreeCreate** | worktree 생성 | 미지원 |
| **WorktreeRemove** | worktree 제거 | 미지원 |
| **PreCompact** | 컨텍스트 압축 직전 | `trigger`: manual, auto |
| **TeammateIdle** | 팀원 idle 전환 | 미지원 |

### matcher란?

hook 이벤트에 지정할 수 있는 **필터링 조건**. matcher가 지원되면 특정 상황에서만 hook을 발동시킬 수 있다.

- **지원 예**: PreToolUse의 `tool_name` matcher → `"Bash"`일 때만 발동하도록 설정 가능
- **미지원**: UserPromptSubmit, Stop 등은 matcher가 없으므로 **해당 이벤트 발생 시 무조건 발동**. 선별적 트리거가 필요하면 스크립트 내부에서 직접 분기 처리해야 한다.

### 공통 stdin 필드 (모든 hook)

```json
{ "session_id", "transcript_path", "cwd", "permission_mode", "hook_event_name" }
```

### Hook 실행 모델

공식 문서:
> **"All matching hooks run in parallel, and identical handlers are deduplicated automatically."**

- 같은 hooks 배열 내 복수 hook은 **병렬 실행**, 각각 **독립 프로세스**로 fork
- 각 프로세스에 **동일한 JSON이 독립적으로 stdin에 주입**
- 따라서 script-A가 stdin을 소비해도 script-B에 영향 없음

---

## 3. 실측 테스트 결과 (2026-02-24)

### 테스트 환경

글로벌 `settings.json`에 3개 hook을 등록, 각각 stdin을 `/tmp/` 파일에 덤프.

### 결과

| Hook | 파일 생성 | session_id 포함 | 동일 UUID |
|------|----------|----------------|----------|
| SessionStart | ✅ | ✅ | ✅ `250802d8-...` |
| Stop | ✅ | ✅ | ✅ `250802d8-...` |
| UserPromptSubmit | ✅ | ✅ | ✅ `250802d8-...` |

### 각 hook의 수신 필드

| 필드 | SessionStart | Stop | UserPromptSubmit |
|------|:---:|:---:|:---:|
| `session_id` | ✅ | ✅ | ✅ |
| `transcript_path` | ✅ | ✅ | ✅ |
| `cwd` | ✅ | ✅ | ✅ |
| `hook_event_name` | ✅ | ✅ | ✅ |
| `permission_mode` | ❌ | ✅ | ✅ |
| `source` | ✅ | ❌ | ❌ |
| `model` | ✅ | ❌ | ❌ |
| `stop_hook_active` | ❌ | ✅ | ❌ |
| `last_assistant_message` | ❌ | ✅ | ❌ |
| `prompt` | ❌ | ❌ | ✅ |

상세 테스트 결과: `세션ID테스트_1차_훅실측_20260224.md` 참조.

---

## 4. /wrap 워크플로우 기준 Hook 발동 흐름

```
사용자: "/wrap" 입력
  │
  ├─ [UserPromptSubmit 발동] ← 프롬프트 제출 직후, AI 처리 전
  │   stdin: { session_id, prompt: "/wrap", ... }
  │
  ▼
Claude가 /wrap 스킬을 해석하고 실행 시작
  │
  ├─ Step 1: git status 실행
  │   ├─ [PreToolUse 발동] (matcher: "Bash")
  │   └─ [PostToolUse 발동] (matcher: "Bash")
  │
  ├─ Step 2: 4개 서브에이전트 병렬 실행
  │   ├─ [SubagentStart 발동] ×4
  │   └─ [SubagentStop 발동] ×4
  │
  ├─ Step 3: duplicate-checker 실행
  │   ├─ [SubagentStart 발동]
  │   └─ [SubagentStop 발동]
  │
  ├─ Step 4: AskUserQuestion (사용자 선택)
  │   └─ [UserPromptSubmit 발동] ← 사용자 응답 시
  │
  ├─ [Stop 발동] ← 이 턴의 응답 완료
  │
  ├─ Step 5: handoff 파일 작성 + CLAUDE.md 업데이트
  │   ├─ [PreToolUse / PostToolUse 발동] (Bash, Write 등)
  │   └─ ...
  │
  └─ [Stop 발동] ← 최종 턴 완료
```

---

## 5. 3개 후보 비교 분석

| 기준 | SessionStart | UserPromptSubmit | Stop |
|------|:---:|:---:|:---:|
| session_id 포함 | ✅ | ✅ | ✅ |
| /wrap 실행 시 발동 | ❌ (세션 시작 시 이미 완료) | ✅ (/wrap 입력 시) | ✅ (각 턴 완료 시) |
| 발동 횟수 (세션 전체) | 1회 | 사용자 프롬프트 수만큼 | AI 턴 수만큼 |
| /wrap에서의 발동 횟수 | 0회 | 1~2회 | 1~2회 |
| handoff 작성 시점에 가용 | ✅ (파일로 미리 저장) | ✅ (AI 처리 전 저장) | ✅ (턴 완료 후 저장) |
| 추가 유용 정보 | model, source | prompt | last_assistant_message |
| 안정성 (실측) | ⚠️ 플러그인 hook 원인불명 실패 | ✅ | ✅ |

### SessionStart

- 세션당 1회로 가장 효율적
- 그러나 **플러그인 hooks.json에서 원인불명 실패** 이력
  - stdin 공유 문제는 아님 (공식 문서: 병렬 실행, 독립 stdin)
  - 추정: `${CLAUDE_PLUGIN_ROOT}` 경로 해석 또는 MSYS 환경 문제
- 글로벌 settings.json에서는 정상 동작

### UserPromptSubmit

- 사용자 프롬프트당 1회 발동 (세션에서 보통 10~30회)
- /wrap 입력 시 **즉시** 발동 → AI 처리 전에 session_id 파일 확보
- "매 턴 낭비"라는 비판은 부정확 — 사용자 입력 시에만 발동

### Stop

- 매 턴 완료 시 발동 → /wrap 실행 중에도 반복 발동
- session_id 저장 목적으로는 과도
- `last_assistant_message` 필드는 다른 용도로 유용할 수 있음

---

## 6. 결론: UserPromptSubmit 채택

### 선정 이유

1. **/wrap 입력 즉시 발동** — session_id가 handoff 작성 전에 확실히 가용
2. **성능 효율**: 경량 스크립트(jq + echo)를 프롬프트당 1회 실행, 무시할 수준
3. **안정성**: 글로벌 테스트에서 정상 동작 확인, 플러그인 hook 실패 리스크 회피
4. **타이밍 최적**: AI 처리 전에 발동하므로 wrap 스킬 실행 시 파일이 이미 존재

### 대안 (SessionStart 실패 원인 규명 시)

플러그인 hook 실행 환경 문제가 해결되면, SessionStart(세션당 1회)로 전환하는 것이 더 효율적. 현재는 안정성 우선으로 UserPromptSubmit 채택.

---

## 7. 구현 명세

### 수정 대상 파일

| 파일 | 변경 |
|------|------|
| `my-session-wrap/hooks/hooks.json` | SessionStart에서 capture 제거, UserPromptSubmit 추가 |
| `my-session-wrap/hooks/capture-session-id.sh` | 환경변수 → 파일 기반 리팩터 |
| `my-session-wrap/skills/my-session-wrap/SKILL.md` | `$CLAUDE_SESSION_ID` → `cat .claude/.current-session-id` |

### 검증 절차

1. `/plugin update` 실행
2. 새 세션 시작 → 아무 프롬프트 1개 입력
3. `cat .claude/.current-session-id`로 UUID 확인
4. `/wrap` 실행 → handoff에 session_id 포함 확인
