# 세션 ID 테스트 4차 — 3개 이벤트 병렬 디버그 계획

> 작성일: 2026-02-24
> 이전 문서: `플러그인진단_세션ID테스트3차_20260224.md`
> 목적: capture-session-id.js의 실패 지점을 3단계 디버그로 특정 + 3개 hook 이벤트 병렬 비교

---

## 1. Context

3차 테스트: Node.js 전환 완료, `UserPromptSubmit hook success` 확인, 하지만 `.current-session-id` 파일 미생성. try/catch가 에러를 삼키고 있어 원인 파악 불가. 3차 계획의 4-1(디버그 모드) 단계를 실행해야 함.

---

## 2. 사전 작업 (이번 세션에서 완료)

### 작업 A: 1차 문서 크로스체크 반영 ✅

**파일**: `세션id 획득 테스트결과_20260224.md`

line 104~116의 "stdin 공유" 결론이 **오류**임을 정정:

```
기존 (line 112-116):
  같은 hooks 배열 내 복수 hook은 stdin을 공유하며,
  첫 번째 hook이 stdin을 소비하면 이후 hook은 빈 데이터를 받는다.

정정:
  2차 테스트에서 capture-session-id.sh 실패의 실제 원인은
  Windows cmd.exe에서 bash/.sh 실행 불가(가설 6)로 확정됨.
  ensure-commands.js(node)가 stdin을 소비한 것이 아니라,
  bash 프로세스 자체가 fork되지 않았음.
  stdin 공유 가설은 미검증 상태이며, 근본 원인이 아님.
```

해당 섹션에 `> **⚠️ 정정**` 블록 추가, 제목도 "당초 추정"으로 수정 완료.

### 작업 B: 3차 문서 테스트 결과 반영 ✅

**파일**: `플러그인진단_세션ID테스트3차_20260224.md`

1. 섹션 5 타임라인 업데이트:
   - "capture-session-id.js 생성 + hooks.json 수정" → **완료** (커밋 3192672)
   - "디버그 모드 1차 테스트" → **진행 중**

2. 섹션 5-1 추가 — "4-1 디버그 사전 확인 결과":
   - hook 실행: ✅ (`UserPromptSubmit hook success` 시스템 메시지)
   - `.current-session-id` 생성: ❌
   - 디버그 파일: ❌
   - 결론: 디버그 코드를 개선하여 3개 이벤트 병렬 테스트 필요

---

## 3. 3개 이벤트 병렬 디버그 테스트 ✅

### 수정 파일

- `my-session-wrap/hooks/capture-session-id.js` — 디버그 코드 교체
- `my-session-wrap/hooks/hooks.json` — SessionStart, Stop 이벤트에 디버그 훅 추가

### 설계: 단일 스크립트 + CLI 인자로 이벤트 구분

`capture-session-id.js`를 범용 디버그 프로브로 확장. 이벤트명을 CLI 인자로 받음:

```
node capture-session-id.js SessionStart
node capture-session-id.js UserPromptSubmit
node capture-session-id.js Stop
```

### hooks.json 변경

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/ensure-commands.js\"",
            "timeout": 3000
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" SessionStart",
            "timeout": 3000
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" UserPromptSubmit",
            "timeout": 3000
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" Stop",
            "timeout": 3000
          }
        ]
      }
    ]
  }
}
```

**SessionStart 배치**: `ensure-commands.js`와 **별도 배열 항목**(별도 hook 그룹)으로 등록. 이렇게 하면 stdin 독립 수신 여부도 함께 검증됨.

### capture-session-id.js 디버그 코드

```js
#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const HOME = process.env.HOME || process.env.USERPROFILE;
const LOG = path.join(HOME, "hook-debug.log");
const EVENT = process.argv[2] || "unknown";
const ts = () => new Date().toISOString();

function log(msg) {
  console.log(msg);                                          // stdout → Claude 응답
  try { fs.appendFileSync(LOG, msg + "\n"); } catch (_) {}   // 파일 누적
}

// STEP 1: 훅 발동 확인 — stdin 이벤트와 무관하게 즉시
log(`[${ts()}] STEP1: ${EVENT} fired (pid=${process.pid})`);

let input = "";
process.stdin.on("data", (chunk) => { input += chunk; });

process.stdin.on("end", () => {
  // STEP 2: stdin 수신 확인
  log(`[${ts()}] STEP2(${EVENT}): stdin=${input.length} bytes`);
  log(`  raw: ${input.substring(0, 300)}`);

  if (!input) {
    log(`  => ABORT: stdin empty`);
    return;
  }

  try {
    const data = JSON.parse(input);
    const sessionId = data.session_id;
    const cwd = data.cwd;

    // STEP 3: 필드 존재 확인
    log(`[${ts()}] STEP3(${EVENT}): keys=[${Object.keys(data).join(",")}]`);
    log(`  session_id=${sessionId || "(없음)"}`);
    log(`  cwd=${cwd || "(없음)"}`);

    if (sessionId && cwd) {
      const dest = path.join(cwd, ".claude", ".current-session-id");
      fs.mkdirSync(path.dirname(dest), { recursive: true });
      fs.writeFileSync(dest, sessionId);
      log(`  => WRITTEN: ${dest}`);
    } else {
      log(`  => SKIPPED: missing ${!sessionId ? "session_id" : "cwd"}`);
    }
  } catch (e) {
    log(`  => ERROR: ${e.message}`);
  }
});
```

### 이중 출력의 원리

| 채널 | 방식 | 용도 |
|------|------|------|
| **stdout** (`console.log`) | Claude 시스템 메시지에 포함 | 파일 유실 시에도 응답에서 확인 |
| **파일** (`~/hook-debug.log`) | `appendFileSync`로 누적 | 이력 보존, 상세 분석 |

---

## 4. 검증: 한 세션으로 3개 이벤트 전부 확인

1. `/plugin update` → 새 세션 시작 → **SessionStart** 발동
2. 프롬프트 입력 → **UserPromptSubmit** 발동
3. 세션 종료 (`/exit` 또는 Ctrl+C) → **Stop** 발동
4. 확인: `cat ~/hook-debug.log` + 각 시스템 메시지의 stdout 출력

---

## 5. 판정 기준

| 로그 내용 | 진단 | 다음 조치 |
|-----------|------|----------|
| 3개 이벤트 모두 STEP1~3 + WRITTEN | 전부 성공 | 최적 이벤트 선택 후 디버그 제거 |
| 특정 이벤트만 성공 | 이벤트별 차이 분석 | 성공한 이벤트 채택 |
| STEP1만, STEP2 없음 | stdin "end" 미발생 | timeout/pipe 문제 |
| STEP2: `stdin=0 bytes` | stdin 비어있음 | 데이터 미전달 문제 |
| STEP3: `session_id=(없음)` | 필드 미제공 | 해당 이벤트의 stdin 스펙 문제 |
| `=> ERROR` | 파일 쓰기 실패 | 에러 메시지로 원인 특정 |

---

## 6. 커밋 이력

| 커밋 | 내용 |
|------|------|
| `02663bd` | docs: 1차 문서 stdin 공유 오결론 정정 + 3차 문서 테스트 결과 반영 |
| `1f390cf` | fix(my-session-wrap): 3개 이벤트 병렬 디버그 + stdout/파일 이중 출력 |

---

## 7. 테스트 결과

> 테스트 실행: 2026-02-24, Claude Code v2.1.51

### 실행 환경

- 소스 커밋 `1f390cf` → `/plugin update` 후 새 세션 시작
- 설치 경로 `~/.claude/plugins/marketplaces/my-claude-plugins/my-session-wrap/hooks/` 파일 일치 확인

### 결과

| 이벤트 | STEP1 | STEP2 | STEP3 | 파일 생성 | 비고 |
|--------|:---:|:---:|:---:|:---:|------|
| SessionStart | ❌ | ❌ | ❌ | ❌ | stdout 출력 없음, hook-debug.log 미생성 |
| UserPromptSubmit | ❌ | ❌ | ❌ | ❌ | "hook success: Success"는 bkit 훅 출력으로 판명 |
| Stop | ❓ | ❓ | ❓ | ❌ | 세션 종료 후 hook-debug.log 없음으로 미실행 추정 |

### 근거

1. `~/hook-debug.log` 파일 미생성 → STEP1(즉시 실행, stdin 무관)조차 도달하지 않음
2. 시스템 메시지에 STEP1 stdout 출력 없음
3. `SessionStart:startup hook success: Success` — `ensure-commands.js`만 실행됨
4. `UserPromptSubmit hook success: Success` — bkit의 `user-prompt-handler.js` 출력

**결론**: capture-session-id.js가 **3개 이벤트 모두에서 미실행**.

---

## 8. bkit 비교 분석 — 원인 추정

### bkit hooks.json vs my-session-wrap hooks.json 구조 비교

| 항목 | my-session-wrap | bkit | 실행 여부 |
|------|----------------|------|----------|
| SessionStart 그룹 수 | 2개 (같은 배열) | 1개 | bkit ✅ |
| 그룹1 matcher | `"startup"` | 없음 | ✅ / ✅ |
| 그룹2 matcher | 없음 | N/A | ❌ |
| `once` 속성 | 없음 | `true` | — |
| UserPromptSubmit | 1개 그룹 (matcher 없음) | 1개 그룹 (matcher 없음) | bkit ✅, my-session-wrap ❌ |
| Stop | 1개 그룹 (matcher 없음) | 1개 그룹 (matcher 없음) | bkit ✅, my-session-wrap ❌ |

### 가설

**가설 A (SessionStart)**: 같은 플러그인·같은 이벤트 내 복수 hook 그룹에서, 첫 그룹이 matcher로 매칭되면 이후 그룹은 short-circuit(건너뜀). 다른 플러그인 간에는 독립 실행됨.

**가설 B (UserPromptSubmit/Stop)**: 가설 A로는 UserPromptSubmit/Stop의 미실행을 설명할 수 없음 (단일 그룹인데도 미실행). 같은 이벤트에 대해 **다른 플러그인이 이미 해당 이벤트 훅을 등록**한 경우, 특정 조건에서 실행 순서나 타임아웃에 의해 누락될 가능성.

**가설 C (공통)**: 플러그인 내 hooks.json의 SessionStart에 복수 그룹이 있으면 **해당 플러그인의 모든 이벤트 훅이 무효화**되는 파싱 버그 가능성. (ensure-commands.js만 예외적으로 `matcher: "startup"`이 있어 실행됨)

---

## 9. 5차 테스트 계획: hook 그룹 병합

### 목적

가설 A/C를 검증 — SessionStart의 복수 그룹을 단일 그룹으로 병합하여 3개 이벤트 전부 실행되는지 확인.

### 수정 내용

**hooks.json 변경 — SessionStart 2개 그룹 → 1개 그룹 병합**:

```json
"SessionStart": [
  {
    "matcher": "startup",
    "hooks": [
      {
        "type": "command",
        "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/ensure-commands.js\"",
        "timeout": 3000
      },
      {
        "type": "command",
        "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" SessionStart",
        "timeout": 3000
      }
    ]
  }
]
```

UserPromptSubmit, Stop은 변경 없이 유지 (단일 그룹 → 가설 C 검증).

### 검증 순서

1. hooks.json 수정 → 커밋
2. 새 세션에서 `/plugin update` 실행
3. 새 세션 시작 → SessionStart STEP1 stdout 출력 확인
4. 프롬프트 입력 → UserPromptSubmit STEP1 확인
5. `cat ~/hook-debug.log` → 파일 생성 + 내용 확인
6. 세션 종료 → Stop STEP1 확인 (hook-debug.log에 기록)

### 판정

| 결과 | 의미 | 다음 조치 |
|------|------|----------|
| 3개 이벤트 모두 STEP1 출력 | 가설 A 확인 (복수 그룹 short-circuit) | 최적 이벤트 선택 후 프로덕션 코드 전환 |
| SessionStart만 성공, 나머지 실패 | 가설 C 확인 (복수 그룹이 전체 무효화) | 병합만으로 해결됨 |
| 전부 실패 | 가설 A/C 모두 아님 | 플러그인 로딩 순서, `${CLAUDE_PLUGIN_ROOT}` 해석, Node.js 경로 문제 등 추가 조사 |
