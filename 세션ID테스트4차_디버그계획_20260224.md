# 세션 ID 테스트 4차 — 3개 이벤트 병렬 디버그 계획

> 작성일: 2026-02-24
> 이전 문서: `플러그인진단_세션ID테스트3차_20260224.md`
> 목적: capture-session-id.js의 실패 지점을 3단계 디버그로 특정 + 3개 hook 이벤트 병렬 비교

---

## 1. Context

3차 테스트: Node.js 전환 완료, `UserPromptSubmit hook success` 확인, 하지만 `.current-session-id` 파일 미생성. try/catch가 에러를 삼키고 있어 원인 파악 불가. 3차 계획의 4-1(디버그 모드) 단계를 실행해야 함.

---

## 2. 사전 작업 (이번 세션에서 완료)

### 작업 A: 1차 문서 크로스체크 반영 ✅

**파일**: `세션id 획득 테스트결과_20260224.md`

line 104~116의 "stdin 공유" 결론이 **오류**임을 정정:

```
기존 (line 112-116):
  같은 hooks 배열 내 복수 hook은 stdin을 공유하며,
  첫 번째 hook이 stdin을 소비하면 이후 hook은 빈 데이터를 받는다.

정정:
  2차 테스트에서 capture-session-id.sh 실패의 실제 원인은
  Windows cmd.exe에서 bash/.sh 실행 불가(가설 6)로 확정됨.
  ensure-commands.js(node)가 stdin을 소비한 것이 아니라,
  bash 프로세스 자체가 fork되지 않았음.
  stdin 공유 가설은 미검증 상태이며, 근본 원인이 아님.
```

해당 섹션에 `> **⚠️ 정정**` 블록 추가, 제목도 "당초 추정"으로 수정 완료.

### 작업 B: 3차 문서 테스트 결과 반영 ✅

**파일**: `플러그인진단_세션ID테스트3차_20260224.md`

1. 섹션 5 타임라인 업데이트:
   - "capture-session-id.js 생성 + hooks.json 수정" → **완료** (커밋 3192672)
   - "디버그 모드 1차 테스트" → **진행 중**

2. 섹션 5-1 추가 — "4-1 디버그 사전 확인 결과":
   - hook 실행: ✅ (`UserPromptSubmit hook success` 시스템 메시지)
   - `.current-session-id` 생성: ❌
   - 디버그 파일: ❌
   - 결론: 디버그 코드를 개선하여 3개 이벤트 병렬 테스트 필요

---

## 3. 3개 이벤트 병렬 디버그 테스트 ✅

### 수정 파일

- `my-session-wrap/hooks/capture-session-id.js` — 디버그 코드 교체
- `my-session-wrap/hooks/hooks.json` — SessionStart, Stop 이벤트에 디버그 훅 추가

### 설계: 단일 스크립트 + CLI 인자로 이벤트 구분

`capture-session-id.js`를 범용 디버그 프로브로 확장. 이벤트명을 CLI 인자로 받음:

```
node capture-session-id.js SessionStart
node capture-session-id.js UserPromptSubmit
node capture-session-id.js Stop
```

### hooks.json 변경

```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "startup",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/ensure-commands.js\"",
            "timeout": 3000
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" SessionStart",
            "timeout": 3000
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" UserPromptSubmit",
            "timeout": 3000
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/hooks/capture-session-id.js\" Stop",
            "timeout": 3000
          }
        ]
      }
    ]
  }
}
```

**SessionStart 배치**: `ensure-commands.js`와 **별도 배열 항목**(별도 hook 그룹)으로 등록. 이렇게 하면 stdin 독립 수신 여부도 함께 검증됨.

### capture-session-id.js 디버그 코드

```js
#!/usr/bin/env node
const fs = require("fs");
const path = require("path");
const HOME = process.env.HOME || process.env.USERPROFILE;
const LOG = path.join(HOME, "hook-debug.log");
const EVENT = process.argv[2] || "unknown";
const ts = () => new Date().toISOString();

function log(msg) {
  console.log(msg);                                          // stdout → Claude 응답
  try { fs.appendFileSync(LOG, msg + "\n"); } catch (_) {}   // 파일 누적
}

// STEP 1: 훅 발동 확인 — stdin 이벤트와 무관하게 즉시
log(`[${ts()}] STEP1: ${EVENT} fired (pid=${process.pid})`);

let input = "";
process.stdin.on("data", (chunk) => { input += chunk; });

process.stdin.on("end", () => {
  // STEP 2: stdin 수신 확인
  log(`[${ts()}] STEP2(${EVENT}): stdin=${input.length} bytes`);
  log(`  raw: ${input.substring(0, 300)}`);

  if (!input) {
    log(`  => ABORT: stdin empty`);
    return;
  }

  try {
    const data = JSON.parse(input);
    const sessionId = data.session_id;
    const cwd = data.cwd;

    // STEP 3: 필드 존재 확인
    log(`[${ts()}] STEP3(${EVENT}): keys=[${Object.keys(data).join(",")}]`);
    log(`  session_id=${sessionId || "(없음)"}`);
    log(`  cwd=${cwd || "(없음)"}`);

    if (sessionId && cwd) {
      const dest = path.join(cwd, ".claude", ".current-session-id");
      fs.mkdirSync(path.dirname(dest), { recursive: true });
      fs.writeFileSync(dest, sessionId);
      log(`  => WRITTEN: ${dest}`);
    } else {
      log(`  => SKIPPED: missing ${!sessionId ? "session_id" : "cwd"}`);
    }
  } catch (e) {
    log(`  => ERROR: ${e.message}`);
  }
});
```

### 이중 출력의 원리

| 채널 | 방식 | 용도 |
|------|------|------|
| **stdout** (`console.log`) | Claude 시스템 메시지에 포함 | 파일 유실 시에도 응답에서 확인 |
| **파일** (`~/hook-debug.log`) | `appendFileSync`로 누적 | 이력 보존, 상세 분석 |

---

## 4. 검증: 한 세션으로 3개 이벤트 전부 확인

1. `/plugin update` → 새 세션 시작 → **SessionStart** 발동
2. 프롬프트 입력 → **UserPromptSubmit** 발동
3. 세션 종료 (`/exit` 또는 Ctrl+C) → **Stop** 발동
4. 확인: `cat ~/hook-debug.log` + 각 시스템 메시지의 stdout 출력

---

## 5. 판정 기준

| 로그 내용 | 진단 | 다음 조치 |
|-----------|------|----------|
| 3개 이벤트 모두 STEP1~3 + WRITTEN | 전부 성공 | 최적 이벤트 선택 후 디버그 제거 |
| 특정 이벤트만 성공 | 이벤트별 차이 분석 | 성공한 이벤트 채택 |
| STEP1만, STEP2 없음 | stdin "end" 미발생 | timeout/pipe 문제 |
| STEP2: `stdin=0 bytes` | stdin 비어있음 | 데이터 미전달 문제 |
| STEP3: `session_id=(없음)` | 필드 미제공 | 해당 이벤트의 stdin 스펙 문제 |
| `=> ERROR` | 파일 쓰기 실패 | 에러 메시지로 원인 특정 |

---

## 6. 커밋 이력

| 커밋 | 내용 |
|------|------|
| `02663bd` | docs: 1차 문서 stdin 공유 오결론 정정 + 3차 문서 테스트 결과 반영 |
| `1f390cf` | fix(my-session-wrap): 3개 이벤트 병렬 디버그 + stdout/파일 이중 출력 |
| `7d78c12` | docs: 4차 디버그 테스트 결과 + bkit 비교 분석 + 5차 계획 추가 |
| (pending) | docs: 1차 테스트 무효 판정 + 서브 플러그인 미설치 원인 정정 + 2차 테스트 계획 |

---

## 7. 1차 테스트 결과 (무효 — 서브 플러그인 미설치)

> 테스트 실행: 2026-02-24, Claude Code v2.1.51

### ⚠️ 테스트 무효 판정

**이전에 `my-session-wrap` 서브 플러그인을 uninstall한 뒤, 마켓플레이스(`/plugin update`)만 재설치하고 서브 플러그인을 개별 설치(`/plugin install`)하지 않은 상태에서 테스트를 진행했음.**

Claude Code 플러그인 시스템에서는:
- `/plugin update` → 마켓플레이스 레포 전체를 `~/.claude/plugins/marketplaces/`에 동기화
- 그러나 개별 서브 플러그인의 **hooks/skills/agents 로딩**은 해당 서브 플러그인이 **설치 등록**되어야 활성화됨
- 파일이 `marketplaces/` 경로에 물리적으로 존재해도, 설치 등록 없으면 Claude Code가 hooks.json을 로드하지 않음

따라서 `capture-session-id.js` 미실행의 원인은 hooks.json 구조 문제가 아니라 **플러그인 미설치**였음.

### 1차 결과 (참고용 — 무효)

| 이벤트 | STEP1 | STEP2 | STEP3 | 파일 생성 | 비고 |
|--------|:---:|:---:|:---:|:---:|------|
| SessionStart | ❌ | ❌ | ❌ | ❌ | 플러그인 미설치로 훅 미로드 |
| UserPromptSubmit | ❌ | ❌ | ❌ | ❌ | 동일 원인 |
| Stop | ❌ | ❌ | ❌ | ❌ | 동일 원인 |

### 1차 분석 시 오류

- `SessionStart:startup hook success: Success` 출력을 `ensure-commands.js` 실행으로 오판 → 실제로는 bkit 등 다른 플러그인의 출력이었을 가능성
- `UserPromptSubmit hook success: Success` → bkit의 `user-prompt-handler.js` 출력
- hook 그룹 short-circuit 가설(가설 A/B/C)은 **전제가 잘못됨** — 플러그인 자체가 로드되지 않았으므로 구조 문제가 아님

---

## 8. bkit 비교 분석 — ~~원인 추정~~ (1차 분석, 전제 오류로 무효)

> **⚠️ 무효**: 아래 분석은 my-session-wrap 서브 플러그인이 설치된 상태라는 전제 하에 수행되었으나, 실제로는 미설치 상태였음. 가설 A/B/C 모두 검증 불필요.

<details>
<summary>접기 — 1차 분석 원문 (참고용)</summary>

### bkit hooks.json vs my-session-wrap hooks.json 구조 비교

| 항목 | my-session-wrap | bkit | 실행 여부 |
|------|----------------|------|----------|
| SessionStart 그룹 수 | 2개 (같은 배열) | 1개 | bkit ✅ |
| 그룹1 matcher | `"startup"` | 없음 | ✅ / ✅ |
| 그룹2 matcher | 없음 | N/A | ❌ |
| `once` 속성 | 없음 | `true` | — |
| UserPromptSubmit | 1개 그룹 (matcher 없음) | 1개 그룹 (matcher 없음) | bkit ✅, my-session-wrap ❌ |
| Stop | 1개 그룹 (matcher 없음) | 1개 그룹 (matcher 없음) | bkit ✅, my-session-wrap ❌ |

### 가설 (무효)

**가설 A**: 같은 플러그인·같은 이벤트 내 복수 hook 그룹 short-circuit
**가설 B**: 다른 플러그인 간 실행 순서/타임아웃 누락
**가설 C**: 복수 그룹이 전체 훅 무효화하는 파싱 버그

</details>

---

## 9. 2차 테스트 계획: 서브 플러그인 설치 후 재테스트

### 배경

서브 플러그인 미설치 → 재설치 완료. **hooks.json은 기존 구조(복수 그룹) 그대로** 테스트하여, 원래 설계가 정상 작동하는지 확인.

### 사전 조건

- `my-session-wrap` 서브 플러그인 설치 완료 (다른 세션에서 실행됨)
- hooks.json 변경 없음 (SessionStart 2개 그룹 구조 유지)

### 검증 순서

1. 새 세션 시작 → SessionStart STEP1 stdout 출력 확인
2. 프롬프트 입력 → UserPromptSubmit STEP1 확인
3. `cat ~/hook-debug.log` → 파일 생성 + 내용 확인
4. 세션 종료 → Stop STEP1 확인 (hook-debug.log에 기록)

### 판정 기준

| 결과 | 의미 | 다음 조치 |
|------|------|----------|
| 3개 이벤트 모두 STEP1~3 + WRITTEN | 전부 성공 | 최적 이벤트 선택 후 디버그 코드 제거 |
| 특정 이벤트만 성공 | 이벤트별 차이 분석 | 성공 이벤트 채택 |
| SessionStart 그룹2만 실패 | 복수 그룹 short-circuit 가설 부활 | 그룹 병합 후 재테스트 |
| 전부 실패 | 설치 등록은 됐으나 다른 문제 | `${CLAUDE_PLUGIN_ROOT}` 해석, 경로 문제 등 추가 조사 |

### 2차 테스트 결과 ✅ 전부 성공

> 테스트 실행: 2026-02-24 10:12~10:15, Claude Code v2.1.51
> 대표 세션: `a8b70488-6c95-4dfc-b765-b05e452ae5b5`

| 이벤트 | STEP1 | STEP2 | STEP3 | 파일 생성 | 비고 |
|--------|:---:|:---:|:---:|:---:|------|
| SessionStart | ✅ | ✅ (326 bytes) | ✅ (session_id=✅, cwd=✅) | ✅ | keys: session_id, transcript_path, cwd, hook_event_name, source, model |
| UserPromptSubmit | ✅ | ✅ (342 bytes) | ✅ (session_id=✅, cwd=✅) | ✅ | keys: + permission_mode, prompt |
| Stop | ✅ | ✅ (593 bytes) | ✅ (session_id=✅, cwd=✅) | ✅ | keys: + stop_hook_active, last_assistant_message |

**hook-debug.log 존재**: ✅ (162줄, 8개 세션 누적)

### 2차 결론

- **1차 실패 원인 확정**: 서브 플러그인 미설치. hooks.json 구조(복수 그룹) 문제 아님.
- **3개 이벤트 모두 정상**: stdin 독립 수신, JSON 파싱, 파일 쓰기 전부 성공.
- **stdin 공유 문제 없음**: SessionStart를 ensure-commands.js와 별도 배열 항목으로 등록해도 stdin이 독립 전달됨.
- **최적 이벤트**: `SessionStart` — 세션 시작 즉시 1회 발동, session_id 확보에 가장 적합.

### 프로덕션 전환

- `capture-session-id.js`: 디버그 로깅(~/hook-debug.log, STEP 출력, CLI 인자) 제거 → 최소 프로덕션 코드로 전환
- `hooks.json`: UserPromptSubmit, Stop 훅 제거 → SessionStart에서만 실행
- 커밋: (pending)
